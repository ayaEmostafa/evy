<!DOCTYPE html>

<html>
<head>
  <title>events.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
        
          <h1>events.js</h1>
        

        
      </div>

      
        
        
        
          <div class='highlight'><pre><span class="hljs-comment">/* jshint asi:true, boss:true, expr:true, eqnull:true, -W058 */</span></pre></div>
        
      
        
        <pre><code>emmy.js

Version <span class="hljs-number">0.1</span><span class="hljs-number">.0</span>
Ricardo Tomasi &lt;ricardobeat@gmail.com&gt;
License: MIT (http:<span class="hljs-comment">//ricardo.mit-license.org/)</span>
http:<span class="hljs-comment">//github.com/ricardobeat/emmy</span>
</code></pre>
        
      
        
        <p>Emmy is a modern EventEmitter implementation that combines
the best from node’s EventEmitter, EE2 and Backbone. In
default sync mode it should perform better than all of the above,
while offering a compatible API and extra features like a debug mode.</p>

        
          <div class='highlight'><pre>
;(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{</pre></div>
        
      
        
        <p>First we declare some utility variables. The <code>uid</code> is used to assign a unique id
for emitters, if a name has not been provided.</p>

        
          <div class='highlight'><pre>
    <span class="hljs-keyword">var</span> slice = <span class="hljs-built_in">Array</span>.prototype.slice
    <span class="hljs-keyword">var</span> _hasImmediate = (<span class="hljs-keyword">typeof</span> setImmediate === <span class="hljs-string">'function'</span>)
    <span class="hljs-keyword">var</span> uid = <span class="hljs-number">0</span></pre></div>
        
      
        
        <p>Function binding method. Doing this is faster and uses less memory than <code>Function.prototype.bind</code>.</p>

        
          <div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_bind</span> <span class="hljs-params">(fn, context, args)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> fn.apply(context, args)
        }
    }</pre></div>
        
      
        
        <h2 id="eventemitter">EventEmitter</h2>

        
      
        
        
        
      
        
        <p>This is the EventEmitter constructor, accepting a single <em>options</em> object
for configuration. The options are:</p>
<ul>
<li><strong>name</strong>   : <em>String</em>  [optional name]</li>
<li><strong>strict</strong> : <em>Boolean</em> [enable strict mode]</li>
<li><strong>async</strong>  : <em>Boolean</em> [use emitNext by default]</li>
<li><strong>debug</strong>  : <em>Boolean</em> [enable debug mode]</li>
</ul>

        
          <div class='highlight'><pre>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EventEmitter</span> <span class="hljs-params">(options)</span> </span>{
        options || (options = {})

        <span class="hljs-keyword">this</span>._events    = {}               <span class="hljs-comment">// listeners attached to this emitter</span>
        <span class="hljs-keyword">this</span>._listening = []               <span class="hljs-comment">// remote listeners (listenTo)</span>
        <span class="hljs-keyword">this</span>.context    = options.context  <span class="hljs-comment">// default emitter context</span>
        <span class="hljs-keyword">this</span>.eventCount = <span class="hljs-number">0</span>
        <span class="hljs-keyword">this</span>.name       = options.name || ++uid

        <span class="hljs-keyword">if</span> (options.debug) {
            <span class="hljs-keyword">this</span>._debug = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">this</span>._last  = { time: <span class="hljs-number">0</span>, eventCount : <span class="hljs-number">0</span> }
        }

        <span class="hljs-keyword">if</span> (options.strict) {
            <span class="hljs-keyword">this</span>._strict = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">this</span>._eventKeys = options.events
            <span class="hljs-keyword">if</span> (!options.events) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'No events defined for emitter '</span> + <span class="hljs-keyword">this</span>.name)
            }
        }

        <span class="hljs-keyword">if</span> (options.async) {
            <span class="hljs-keyword">this</span>.emitSync = <span class="hljs-keyword">this</span>.emit
            <span class="hljs-keyword">this</span>.emit     = <span class="hljs-keyword">this</span>.emitNext
            <span class="hljs-keyword">this</span>._async   = <span class="hljs-literal">true</span>
        }
    }</pre></div>
        
      
        
        <p>When given the option { strict: true }, an emitter will validate the
event names before adding handlers or emitting an event. This method is shared
by all the methods that manipulate events.</p>

        
          <div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateEvent</span> <span class="hljs-params">(emitter, method, name)</span> </span>{
        <span class="hljs-keyword">if</span> (emitter._strict &amp;&amp; emitter._eventKeys.hasOwnProperty(name)) <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
            method + <span class="hljs-string">"(): event '"</span> + name + <span class="hljs-string">"' has not been registered for emitter "</span> + emitter.name
        )
        err.emitter = emitter
        <span class="hljs-keyword">throw</span> err
    }</pre></div>
        
      
        
        <p>In this case all events must be declared on creation. For example:</p>
<pre><code><span class="hljs-keyword">new</span> EventEmitter({
    strict: <span class="hljs-literal">true</span>,
    events: {
        <span class="hljs-string">'eventName'</span> : <span class="hljs-string">'description'</span>,
        <span class="hljs-string">'open'</span>      : <span class="hljs-string">'Open stuff'</span>,
        <span class="hljs-string">'close'</span>     : <span class="hljs-string">'Close stuff'</span>
    }
})
</code></pre>
        
      
        
        <p>The <strong>addListener</strong> method adds a handler to the events list.</p>

        
          <div class='highlight'><pre>    EventEmitter.prototype.addListener = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, fn, context)</span> </span>{
        <span class="hljs-keyword">this</span>._strict &amp;&amp; validateEvent(<span class="hljs-keyword">this</span>, <span class="hljs-string">'addListener'</span>, name)
        <span class="hljs-keyword">var</span> handlers = <span class="hljs-keyword">this</span>._events[name] || (<span class="hljs-keyword">this</span>._events[name] = [])
        handlers.push(context ? { fn: fn, context: context } : fn)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; handlers.length; i++) {
            <span class="hljs-keyword">if</span> (handlers[i] == <span class="hljs-literal">null</span>) handlers.splice(i, <span class="hljs-number">1</span>)
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
    }</pre></div>
        
      
        
        <p>The <strong>once</strong> method adds a handler that will only get called once, by
removing itself after the first call.</p>

        
          <div class='highlight'><pre>    EventEmitter.prototype.once = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, fn)</span> </span>{
        <span class="hljs-keyword">this</span>._strict &amp;&amp; validateEvent(<span class="hljs-keyword">this</span>, <span class="hljs-string">'once'</span>, name)
        <span class="hljs-keyword">var</span> self  = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">var</span> fired = <span class="hljs-literal">false</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onceFn</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">if</span> (!fired) {
                fired = <span class="hljs-literal">true</span>
                fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)
                self.removeListener(name, onceFn)
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addListener(name, onceFn)
    }</pre></div>
        
      
        
        <p>The <strong>removeListener</strong> method removes an event handler from the events list.</p>

        
          <div class='highlight'><pre>    EventEmitter.prototype.removeListener = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, fn, context)</span> </span>{
        <span class="hljs-keyword">this</span>._strict &amp;&amp; validateEvent(<span class="hljs-keyword">this</span>, <span class="hljs-string">'removeListener'</span>, name)
        <span class="hljs-keyword">var</span> self     = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">var</span> handlers = <span class="hljs-keyword">this</span>._events[name]</pre></div>
        
      
        
        <p>Remove all events, filtering by function if provided</p>

        
          <div class='highlight'><pre>        <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'*'</span>) {
            <span class="hljs-keyword">if</span> (!fn) {
                <span class="hljs-keyword">this</span>._events = {}
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _name <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>._events) {
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._events.hasOwnProperty(_name)) {
                        self.removeListener(_name, fn)
                    }
                }
            }</pre></div>
        
      
        
        <p>Otherwise find handlers that match the given event name and function signature</p>

        
          <div class='highlight'><pre>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fn &amp;&amp; handlers) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; handlers.length; i++) {
                <span class="hljs-keyword">if</span> (handlers[i] &amp;&amp; (handlers[i] === fn || handlers[i].fn === fn)) {
                    <span class="hljs-comment">/* instead of calling .splice(i, 1) here, we'll
                    set this handler to null and defer the cleanup
                    to the next addListener call. */</span>
                    handlers[i] = <span class="hljs-literal">null</span>
                }
            }
            <span class="hljs-keyword">if</span> (handlers.length === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._events[name]
            }</pre></div>
        
      
        
        <p>If only a name was given, remove all handlers for this event</p>

        
          <div class='highlight'><pre>        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._events[name]
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
    }</pre></div>
        
      
        
        <p><strong>emitNext</strong> schedules an event to the next tick, using the methods
available in the environment. Useful when an emitter fires events
straight after creation, without giving listeners a chance to be setup.</p>

        
          <div class='highlight'><pre>    EventEmitter.prototype.emitNext = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> </span>{
        <span class="hljs-keyword">this</span>._strict &amp;&amp; validateEvent(<span class="hljs-keyword">this</span>, <span class="hljs-string">'emitNext'</span>, name)
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, args = <span class="hljs-built_in">arguments</span>
        <span class="hljs-keyword">var</span> run = _bind(EventEmitter.prototype.emit, self, args)
        <span class="hljs-keyword">return</span> _hasImmediate ? setImmediate(run) : setTimeout(run, <span class="hljs-number">0</span>)
    }</pre></div>
        
      
        
        <p>The <strong>emit</strong> method calls all handlers that match the given event type.</p>

        
          <div class='highlight'><pre>    EventEmitter.prototype.emit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> </span>{
        <span class="hljs-keyword">this</span>._strict &amp;&amp; validateEvent(<span class="hljs-keyword">this</span>, <span class="hljs-string">'emit'</span>, name)
        <span class="hljs-keyword">var</span> handlers = <span class="hljs-keyword">this</span>._events[name]
        <span class="hljs-keyword">this</span>._debug &amp;&amp; <span class="hljs-keyword">this</span>.tick()
        <span class="hljs-keyword">if</span> (!handlers) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; handlers.length; i++) {
            <span class="hljs-keyword">var</span> handler = handlers[i]
            <span class="hljs-keyword">if</span> (!handler) <span class="hljs-keyword">continue</span>
            <span class="hljs-keyword">var</span> context = handler.context || <span class="hljs-keyword">this</span>._context || <span class="hljs-keyword">this</span>
            <span class="hljs-keyword">var</span> fn      = handler.fn || handler
            <span class="hljs-keyword">var</span> length  = <span class="hljs-built_in">arguments</span>.length
            <span class="hljs-keyword">switch</span> (length) { <span class="hljs-comment">// optimize most common calls (inspired by Backbone)</span>
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: fn.call(context); <span class="hljs-keyword">break</span>
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: fn.call(context, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]); <span class="hljs-keyword">break</span>
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: fn.call(context, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>], <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>]); <span class="hljs-keyword">break</span>
                <span class="hljs-keyword">default</span>: <span class="hljs-comment">// args optimization borrowed from node EventEmitter (lib/events.js)</span>
                    <span class="hljs-keyword">var</span> args = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(length - <span class="hljs-number">1</span>)
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; length; i++) args[i - <span class="hljs-number">1</span>] = <span class="hljs-built_in">arguments</span>[i]
                    fn.apply(context, args)
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
    }</pre></div>
        
      
        
        <p>The <code>tick</code> method is here for debugging purposes. It keeps count of emitted events over time
and calculates a running average rate for the past 2 seconds. Mostly useful for finding 
accidental loops and optimizing code.
<em>TODO: trigger console warning if rate is too high</em></p>

        
          <div class='highlight'><pre>    EventEmitter.prototype.tick = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> now  = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>
        <span class="hljs-keyword">var</span> last = <span class="hljs-keyword">this</span>._last
        <span class="hljs-keyword">this</span>.eventCount++
        <span class="hljs-keyword">if</span> (now - last.time &gt; <span class="hljs-number">5000</span>) {
            <span class="hljs-keyword">this</span>.rate = <span class="hljs-built_in">Math</span>.floor((<span class="hljs-keyword">this</span>.eventCount - last.eventCount) / (now - last.time) / <span class="hljs-number">1000</span>)
            <span class="hljs-keyword">this</span>._last = { time: now, eventCount: <span class="hljs-keyword">this</span>.eventCount }
        }
    }</pre></div>
        
      
        
        <p>The <strong>proxy</strong> method returns a function that emits $name event on the emitter that
created it. It also accepts a <code>transform</code> function that will be called on the event
data before being forwarded. Use (with caution) to create event chains / pipes.</p>

        
          <div class='highlight'><pre>    EventEmitter.prototype.proxy = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, transform)</span> </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">var</span> args = slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>)
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> transform === <span class="hljs-string">'function'</span>) {
                args = transform.apply(<span class="hljs-literal">null</span>, args)
            }
            args.unshift(name)
            self.emit.apply(self, args)
        }
    }</pre></div>
        
      
        
        <p>The <strong>listenTo</strong> method attaches listeners to another object,
while keeping track of them for easy clean-up. The gist of the implementation
is handled by the <code>RemoteListener</code> objects.</p>

        
          <div class='highlight'><pre>    EventEmitter.prototype.listenTo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target, name, fn, context)</span> </span>{
        <span class="hljs-keyword">var</span> listener = <span class="hljs-keyword">new</span> RemoteListener(target, name, fn, context)
        listener.attach()
        <span class="hljs-keyword">this</span>._listening.push(listener)
    }</pre></div>
        
      
        
        <p><strong>listenToOne</strong> is the same as above but with “once” behaviour, removing itself
after the first call.</p>

        
          <div class='highlight'><pre>    EventEmitter.prototype.listenToOne = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target, name, fn, context)</span> </span>{
        <span class="hljs-keyword">var</span> fired = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">var</span> self  = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">var</span> onceFn = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">if</span> (fired) <span class="hljs-keyword">return</span>
            fired = <span class="hljs-literal">true</span>
            fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)
            self.stopListening(name, onceFn)
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.listenTo(target, name, onceFn, context)
    }</pre></div>
        
      
        
        <p>The <strong>stopListening</strong> method removes all remote listeners.</p>

        
          <div class='highlight'><pre>    EventEmitter.prototype.stopListening = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target, name, fn)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, listener; listener = <span class="hljs-keyword">this</span>._listening[i]; i++) {
            <span class="hljs-keyword">if</span> (listener.matches(target, name, fn)) {
                listener.detach()
            }
        }
    }</pre></div>
        
      
        
        <p>The <strong>destroy</strong> method is a shortcut for easily removing all local <em>and</em> remote listeners.</p>

        
          <div class='highlight'><pre>    EventEmitter.prototype.destroy = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.removeListener(<span class="hljs-string">'*'</span>)
        <span class="hljs-keyword">this</span>.stopListening()
    }</pre></div>
        
      
        
        <h2 id="remotelistener">RemoteListener</h2>

        
      
        
        
        
      
        
        <p>Internal object used by the <code>listenTo()</code> family of methods. Keeps track of all listeners added to
another emitter, forwarding method calls and arguments.</p>

        
          <div class='highlight'><pre>    
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RemoteListener</span> <span class="hljs-params">(target, name, fn, context)</span> </span>{
        <span class="hljs-keyword">this</span>.target  = target
        <span class="hljs-keyword">this</span>.name    = name
        <span class="hljs-keyword">this</span>.fn      = fn
        <span class="hljs-keyword">this</span>.context = context
    }</pre></div>
        
      
        
        <p>Attaches handlers to target.</p>

        
          <div class='highlight'><pre>    RemoteListener.prototype.attach = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> target = <span class="hljs-keyword">this</span>.target
        <span class="hljs-keyword">var</span> method = target.addListener || target.on || target.bind
        method.call(target, <span class="hljs-keyword">this</span>.name, <span class="hljs-keyword">this</span>.fn, <span class="hljs-keyword">this</span>.context)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
    }</pre></div>
        
      
        
        <p>Detaches handlers from target.</p>

        
          <div class='highlight'><pre>    RemoteListener.prototype.detach = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> target = <span class="hljs-keyword">this</span>.target
        <span class="hljs-keyword">var</span> method = target.removeListener || target.off || target.unbind
        method.call(target, <span class="hljs-keyword">this</span>.name, <span class="hljs-keyword">this</span>.fn)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
    }</pre></div>
        
      
        
        <p>Test if listener matches the given arguments, used by <code>stopListening</code>.</p>

        
          <div class='highlight'><pre>    RemoteListener.prototype.matches = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target, name, fn)</span> </span>{
        <span class="hljs-keyword">return</span> (
            (!target || target === <span class="hljs-keyword">this</span>.target) &amp;&amp;
            (!name   || name === <span class="hljs-keyword">this</span>.name) &amp;&amp;
            (!fn     || fn === <span class="hljs-keyword">this</span>.fn)
        )
    }</pre></div>
        
      
        
        <h3 id="convenience-methods">Convenience methods</h3>

        
      
        
        <p>Standard <strong>extend</strong> method, copies all properties and methods to target object.
For use when creating a new emitter instance, or prototypal inheritance, is undesired. </p>

        
          <div class='highlight'><pre>    EventEmitter.extend = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(target, options)</span> </span>{
        EventEmitter.call(target, options)
        <span class="hljs-keyword">var</span> proto = EventEmitter.prototype
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> proto) {
            <span class="hljs-keyword">if</span> (!proto.hasOwnProperty(key)) <span class="hljs-keyword">continue</span>
            target[key] = proto[key]
        }
        <span class="hljs-keyword">return</span> target
    }</pre></div>
        
      
        
        <p><strong>EventEmitter.create</strong> is a shortcut to create a new emitter without the <code>new</code> keyword.
 Makes some people very happy.</p>

        
          <div class='highlight'><pre>    EventEmitter.create = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(options)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EventEmitter(options)
    }</pre></div>
        
      
        
        <p>Create aliases for the most common method names, makes it somewhat compatible with
other emitter implementations.</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">var</span> aliases = {
        on            : <span class="hljs-string">'addListener'</span>,
        off           : <span class="hljs-string">'removeListener'</span>,
        trigger       : <span class="hljs-string">'emit'</span>,
        one           : <span class="hljs-string">'once'</span>,
        publish       : <span class="hljs-string">'emit'</span>,
        subscribe     : <span class="hljs-string">'addListener'</span>,
        unsubscribe   : <span class="hljs-string">'removeListener'</span>
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> aliases) {
        <span class="hljs-keyword">if</span> (!aliases.hasOwnProperty(key)) <span class="hljs-keyword">continue</span>
        EventEmitter.prototype[key] = EventEmitter.prototype[aliases[key]]
    }</pre></div>
        
      
        
        <p>Finally, export the constructor as a commonJS / global / AMD module.</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-built_in">module</span>.exports) {
        <span class="hljs-built_in">module</span>.exports = EventEmitter
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define !== <span class="hljs-string">'undefined'</span>) {
        define(<span class="hljs-string">'Emmy'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> EventEmitter })
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.Emmy = EventEmitter
    }

}).call(<span class="hljs-keyword">this</span>);</pre></div>
        
      
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>
